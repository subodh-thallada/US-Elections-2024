'use strict';

var GetIntrinsic = require('get-intrinsic');

<<<<<<< HEAD
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var isInteger = require('math-intrinsics/isInteger');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var NumberToRawBytes = require('./NumberToRawBytes');

var isArrayBuffer = require('is-array-buffer');
var isSharedArrayBuffer = require('is-shared-array-buffer');
=======
var $TypeError = require('es-errors/type');
var $Uint8Array = GetIntrinsic('%Uint8Array%', true);

var isInteger = require('../helpers/isInteger');

var IsDetachedBuffer = require('./IsDetachedBuffer');
var ToInt16 = require('./ToInt16');
var ToInt32 = require('./ToInt32');
var ToInt8 = require('./ToInt8');
var ToUint16 = require('./ToUint16');
var ToUint32 = require('./ToUint32');
var ToUint8 = require('./ToUint8');
var ToUint8Clamp = require('./ToUint8Clamp');

var isArrayBuffer = require('is-array-buffer');
>>>>>>> 680064e5fdc85884a37bd24dfb3394d654d8dfba
var hasOwn = require('hasown');

var tableTAO = require('./tables/typed-array-objects');

<<<<<<< HEAD
var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');

// https://262.ecma-international.org/8.0/#sec-setvalueinbuffer

/* eslint max-params: 0 */

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value, isTypedArray, order) {
	var isSAB = isSharedArrayBuffer(arrayBuffer);
	if (!isArrayBuffer(arrayBuffer) && !isSAB) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer or a SharedArrayBuffer');
=======
var TypeToAO = {
	__proto__: null,
	Int8: ToInt8,
	Uint8: ToUint8,
	Uint8C: ToUint8Clamp,
	Int16: ToInt16,
	Uint16: ToUint16,
	Int32: ToInt32,
	Uint32: ToUint32
};

var defaultEndianness = require('../helpers/defaultEndianness');
var forEach = require('../helpers/forEach');
var integerToNBytes = require('../helpers/integerToNBytes');
var valueToFloat32Bytes = require('../helpers/valueToFloat32Bytes');
var valueToFloat64Bytes = require('../helpers/valueToFloat64Bytes');

// https://262.ecma-international.org/6.0/#sec-setvalueinbuffer

module.exports = function SetValueInBuffer(arrayBuffer, byteIndex, type, value) {
	if (!isArrayBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: `arrayBuffer` must be an ArrayBuffer');
>>>>>>> 680064e5fdc85884a37bd24dfb3394d654d8dfba
	}

	if (!isInteger(byteIndex)) {
		throw new $TypeError('Assertion failed: `byteIndex` must be an integer');
	}

	if (typeof type !== 'string' || !hasOwn(tableTAO.size, '$' + type)) {
		throw new $TypeError('Assertion failed: `type` must be a Typed Array Element Type');
	}

	if (typeof value !== 'number') {
		throw new $TypeError('Assertion failed: `value` must be a number');
	}

<<<<<<< HEAD
	if (typeof isTypedArray !== 'boolean') {
		throw new $TypeError('Assertion failed: `isTypedArray` must be a boolean');
	}
	if (order !== 'SeqCst' && order !== 'Unordered' && order !== 'Init') {
		throw new $TypeError('Assertion failed: `order` must be `"SeqCst"`, `"Unordered"`, or `"Init"`');
	}

	if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
=======
	if (arguments.length > 4 && typeof arguments[4] !== 'boolean') {
>>>>>>> 680064e5fdc85884a37bd24dfb3394d654d8dfba
		throw new $TypeError('Assertion failed: `isLittleEndian` must be a boolean, if present');
	}

	if (IsDetachedBuffer(arrayBuffer)) {
		throw new $TypeError('Assertion failed: ArrayBuffer is detached'); // step 1
	}

	// 2. Assert: There are sufficient bytes in arrayBuffer starting at byteIndex to represent a value of type.

	if (byteIndex < 0) {
		throw new $TypeError('Assertion failed: `byteIndex` must be non-negative'); // step 3
	}

	// 4. Assert: Type(value) is Number.

<<<<<<< HEAD
	// 5. Let block be arrayBuffer.[[ArrayBufferData]].

	var elementSize = tableTAO.size['$' + type]; // step 6

	// 7. If isLittleEndian is not present, set isLittleEndian to to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.
	var isLittleEndian = arguments.length > 6 ? arguments[6] : defaultEndianness === 'little'; // step 8

	var rawBytes = NumberToRawBytes(type, value, isLittleEndian); // step 8

	if (isSAB) { // step 9
		/*
			Let execution be the [[CandidateExecution]] field of the surrounding agent's Agent Record.
			Let eventList be the [[EventList]] field of the element in execution.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().
			If isTypedArray is true and IsNoTearConfiguration(type, order) is true, let noTear be true; otherwise let noTear be false.
			Append WriteSharedMemory { [[Order]]: order, [[NoTear]]: noTear, [[Block]]: block, [[ByteIndex]]: byteIndex, [[ElementSize]]: elementSize, [[Payload]]: rawBytes } to eventList.
		*/
		throw new $SyntaxError('SharedArrayBuffer is not supported by this implementation');
	} else {
		// 10. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
		var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
		forEach(rawBytes, function (rawByte, i) {
			arr[i] = rawByte;
		});
	}

	// 11. Return NormalCompletion(undefined).
=======
	// 5. Let block be arrayBufferâ€™s [[ArrayBufferData]] internal slot.

	// 6. Assert: block is not undefined.

	var elementSize = tableTAO.size['$' + type]; // step 7
	if (!elementSize) {
		throw new $TypeError('Assertion failed: `type` must be one of "Int8", "Uint8", "Uint8C", "Int16", "Uint16", "Int32", "Uint32", "Float32", or "Float64"');
	}

	// 8. If isLittleEndian is not present, set isLittleEndian to either true or false. The choice is implementation dependent and should be the alternative that is most efficient for the implementation. An implementation must use the same value each time this step is executed and the same value must be used for the corresponding step in the GetValueFromBuffer abstract operation.
	var isLittleEndian = arguments.length > 4 ? arguments[4] : defaultEndianness === 'little'; // step 8

	var rawBytes;
	if (type === 'Float32') { // step 1
		rawBytes = valueToFloat32Bytes(value, isLittleEndian);
	} else if (type === 'Float64') { // step 2
		rawBytes = valueToFloat64Bytes(value, isLittleEndian);
	} else {
		var n = elementSize; // step 3.a

		var convOp = TypeToAO[type]; // step 3.b

		var intValue = convOp(value); // step 3.c

		rawBytes = integerToNBytes(intValue, n, isLittleEndian); // step 3.d, 3.e, 4
	}

	// 12. Store the individual bytes of rawBytes into block, in order, starting at block[byteIndex].
	var arr = new $Uint8Array(arrayBuffer, byteIndex, elementSize);
	forEach(rawBytes, function (rawByte, i) {
		arr[i] = rawByte;
	});

	// 13. Return NormalCompletion(undefined).
>>>>>>> 680064e5fdc85884a37bd24dfb3394d654d8dfba
};
